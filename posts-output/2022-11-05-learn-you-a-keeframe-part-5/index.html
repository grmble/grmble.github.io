<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <meta charset="utf-8" />
    <title>Grmblog</title>
    
<meta name="keywords" content="lyakf,clojure">

<meta name="description" content="It was my pork chop. But that&#39;s ok. I ate his dog food.-- Bam Bam BigelowThe program is not finished, but this part is when it becomes useful.
I just used it in a training session for the first time.  Haha!  Hahaha!">

<meta property="og:description" content="It was my pork chop. But that&#39;s ok. I ate his dog food.-- Bam Bam BigelowThe program is not finished, but this part is when it becomes useful.
I just used it in a training session for the first time.  Haha!  Hahaha!">

<meta property="og:url" content="https://grmble.github.io/posts-output/2022-11-05-learn-you-a-keeframe-part-5/" />
<meta property="og:title" content="Learn You A Kee-Frame, Part 5" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://grmble.github.io/posts-output/2022-11-05-learn-you-a-keeframe-part-5/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
        type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <script src="/js/lunr.min.js"></script>
    <script src="/js/lunr_index.js"></script>
    <script src="/js/lunrclient.js"></script>
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>

<body>


    <nav class="navbar navbar-default">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar"
                    aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">Grmblog</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li ><a href="/">Home</a></li>
                    <li ><a href="/archives/">Archives</a></li>
                    
                    <li >
                        <a href="/pages-output/about/">About</a>
                    </li>
                    
                    <li><a href="/feed.xml">RSS</a></li>
                </ul>
            </div>
            <!--/.nav-collapse -->
        </div>
        <!--/.container-fluid -->
    </nav>


    <div class="container">


        <div class="row">
            <div class="col-lg-9">
                <div id="content">
                    
<div id="post">
    <div class="post-header">
    <div id="post-meta" class="row">
        <div class="col-lg-6">5 November 2022</div>
        
    </div>
    <h2>Learn You A Kee-Frame, Part 5</h2>
</div>
<div>
    
    <blockquote><p>It was my pork chop. But that's ok. I ate his dog food.</p><p>-- Bam Bam Bigelow</p></blockquote><p>The program is not finished, but this part is when it becomes useful.
I just used it in a training session for the first time.  Haha!  Hahaha!</p><h2 id="storage">Storage</h2><p>I had a hard time deciding what to use for storage.  I was pretty far
along with a PouchDB version.  I very much want some kind of sync
between my phone and other devices, PouchDB would be one option.
But this program might be useful for non-technical people,
so I want to make it rock solid.  And so far I have not come
up with a convincing strategy for dealing with eventual conflicts.</p><p>But the storage layer is built with an eye to PouchDB.
In particular, we are producing bog standard JSON that
could be used in a JSON aware database.</p><p>On initialization, there is code in place that reads
<code>:current</code>, <code>:exercises</code> and <code>:programs</code> from local storage.
Right now I injecting them as coeffects, this is only
possible with local storage because it is synchronous.
With PouchDB or IndexedDB, we would have to dispatch
additional events, like we do after reading <code>config.json</code>
over http.</p><pre><code class="clojure">(rf/reg-event-fx :config-loaded
                 [(rf/inject-cofx :grmble.lyakf.frontend.storage.local/load 
                   [:current :exercises :programs])]
                 (fn [{:keys [db current exercises programs]} [_ config]]
                   {:db (cond-&gt; (assoc db :config (merge (:config db) config))
                          true      (assoc-in [:transient :initialized?] true)
                          current   (assoc :current (foreign/js-&gt;current current))
                          exercises (assoc :exercises (foreign/js-&gt;exercises exercises))
                          programs  (assoc :programs (foreign/js-&gt;programs programs)))}))
</code></pre><p>This is the event handler for the <code>:complete</code> event that is
dispatched by the program wizard.</p><p>2 new side effects are used: <code>:store</code> writes the <code>:current</code> part
of app db to local storage. <code>:append-history</code> writes history entries.
This will be used later on to produce our fancy charts (with lines
going ever up!!!).</p><p>The current weights for all exercises are now stored under <code>[:current :weights]</code>.
This is for PouchDB: if there is a conflict with writing this, there might
be changes that are hidden to the user, but at least it would be consistent.</p><p>Now <code>:exercises</code> only changes for configuration changes, same thing with
<code>:programs</code>.</p><pre><code class="clojure">(defn complete-handler [{:keys [db current-date]} [_ selector repsets]]
  (let [slug                   (get-in db [:current :slug])
        program                (-&gt; db :programs (get slug))
        xref                   (program/exercise-ref program selector)
        [completed-slugs data] (program/complete-with-slugs repsets program
                                                            (-&gt; db :current :data)
                                                            selector)
        db (-&gt; db
               (update :current
                       #(reduce (incrementer (:exercises db)) % completed-slugs))
               (update :current #(assoc % :data data)))]
    {:db db

     :grmble.lyakf.frontend.storage.local/store
     {:kvs {:current (foreign/current-&gt;js (:current db))}
      :db db}

     :grmble.lyakf.frontend.storage.local/append-history
     {:current-date current-date
      :slug (:slug xref)
      :repsets repsets}}))
</code></pre><p>Note the use of namespaced keywords.  The idea here is that additional
storage backends would provide the same effects and co-effects,
just in different namespaces.  This would allow to switch between
them.  We would have to stop using coeffects for reading though.</p><h2 id="history">History</h2><p>The data tab now shows our history entries.</p><p>Codemirror is very powerful, we could make a
<code>lezer</code> version of our entry parser and we would
have syntax hightlighting.</p><pre><code class="clojure">(defn- codemirror-content [view]
  (some-&gt; view .-state .-doc .-text))

;; the inner / outer pattern comes straigt from the docs
;; https://day8.github.io/re-frame/Using-Stateful-JS-Components/
(defn codemirror-inner []
  (let [view     (atom nil)
        init!    (fn [comp]
                   (let [history     (:history (r/props comp))
                         state       (.-state @view)
                         length      (or (some-&gt; state .-doc .-length)
                                         0)
                         transaction (.update state #js {:changes #js {:from 0
                                                                       :to length
                                                                       :insert history}})]
                     (.dispatch @view transaction)))]

    (r/create-class
     {:reagent-render         (fn []
                                [:&lt;&gt;
                                 [:div#codemirror]
                                 [:div.control
                                  [:button.button.is-primary
                                   {:on-click
                                    #(&gt;evt [:save-history (codemirror-content @view)])}
                                   "Save"]]])

      :component-did-mount    (fn [comp]
                                (let [elem  (js/document.getElementById "codemirror")
                                      cm    (EditorView.
                                             #js {:extensions #js [basicSetup]
                                                  :parent elem})]
                                  (reset! view cm)
                                  (init! comp)))
      :component-did-update    init!
      :display-name            "codemirror-inner"})))


(defn codemirror-outer []
  (let [transient (&lt;sub [:transient])]
    (fn []
      ;; it is a map so it can be accessed as (r/props cmop)
      [codemirror-inner transient])))
</code></pre><p>For now we just detect errors using our insta-parse parser
(see <code>parser/parse-history</code>) and display the affected
line numbers via flash.</p><p>The history is not usually loaded. For charting, we will only
use a limited subset of the data, so we do not keep it in memory.
I actually worked for quite a while on this because I forgot
about kee-frame's controllers.  Duh.  This is just what
they are for, and the code is so much nicer than my
pure re-frame attempt using <code>reg-sub-raw</code>:</p><pre><code class="clojure">(k/reg-controller :data
                  {:params (fn [match]
                             (when (= (get-in match [:data :name]) :data)
                               true))
                   :start  [:load-history]
                   :stop   [:dispose-history]})
</code></pre><h2 id="resetting-exercises-and-snapshots">Resetting Exercises and Snapshots</h2><p>In the wizard, there is now a reset button next to each exercise.
This toggles a modal form for changing the exercise's current weight:</p><pre><code class="clojure">(defn reset-exercise [exercise show? toggle]
  (r/with-let [value (r/atom (:weight exercise))]
    (let [reset-exercise! (fn [evt]
                            (&gt;evt [:reset-exercise (:slug exercise) @value])
                            (toggle evt))]
      [:form.modal {:class (when @show? :is-active)
                    :on-submit reset-exercise!}
       [:div.modal-background]
       [:div.modal-card
        [:header.modal-card-head
         [:p.modal-card-title (str "Reset " (:name exercise))] ; without the str a very strange error ...
         [:button.delete {:aria-label "close" :type "button" :on-click toggle}]]
        [:section.modal-card-body
         [:input.input {:on-change #(reset! value (-&gt; % .-target .-value))
                        :value @value}]]
        [:footer.modal-card-foot
         [:button.button.is-success
          {:type "submit"
           :on-click reset-exercise!}
          "Save"]
         [:button.button {:on-click toggle} "Cancel"]]]])))
</code></pre><p>There is also a snapshotting feature:  since I am already using the program,
trying things out on my phone now messes up my data.  The history
is easily cleaned up on the data tab, but the current wizard state
is complicated.  So on the dev tab, there are 2 new buttons:
"Snapshot" and "Restore".  I make a snapshot before loading a new build.
This stores the entire <code>:current</code> part of the model into local storage
under a different name.  When I am done playing around I press <code>:restore</code>,
this replaces regular <code>:current</code> storage with the snapshot and also
loads it back in.</p><pre><code class="clojure">(rf/reg-event-fx :snapshot-current
                 (fn [{:keys [db]} [_]]
                   {:db db

                    :grmble.lyakf.frontend.storage.local/store
                    {:kvs {:snapshot (foreign/current-&gt;js (:current db))}
                     :db db}}))

(rf/reg-event-fx :restore-snapshot
                 [(rf/inject-cofx :grmble.lyakf.frontend.storage.local/load [:snapshot])]
                 (fn [{:keys [db snapshot]} [_]]
                   {:db (cond-&gt; db
                          snapshot  (assoc :current (foreign/js-&gt;current snapshot)))

                    :grmble.lyakf.frontend.storage.local/store
                    {:kvs {:current snapshot}
                     :db db}}))
</code></pre><h2 id="release-build-on-gh-pages">Release Build on GH Pages</h2><ul><li><a href="https://grmble.github.io/learn-you-a-keeframe/part5/">Demo: Learn you a Kee-Frame, Part 5</a></li><li><a href="https://github.com/grmble/learn-you-a-keeframe/tree/part5">Source code</a></li></ul><p>340 KB compressed.  Codemirror is a big dependency, but so far I am happy
with the load times.  My phone is a couple of years old now and it runs
like a charm.</p>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags-output/lyakf/">lyakf</a>
    
    <a href="/tags-output/clojure/">clojure</a>
    
</div>


    <div id="prev-next">
        
        
        <a class="right" href="/posts-output/2022-10-31-learn-you-a-keeframe-part-4/">Learn You A Kee-Frame, Part 4 &raquo;</a>
        
    </div>

    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = "https://grmble.github.io/posts-output/2022-11-05-learn-you-a-keeframe-part-5/";
            this.page.identifier = "Learn You A Kee-Frame, Part 5";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//grmble-github-io.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    


</div>

                </div>
            </div>

            <div class="col-md-3">
                <div id="sidebar">
                    <h3>Search</h3>

                    <!--- Search form -->
                    <form id="lunrSearchForm" name="lunrSearchForm" action="/">
                        <input class="search-input" name="q" placeholder="Enter search term" type="text">
                        <input class="button nopadding" type="submit" value="Search">
                    </form>
                    <!--
                <div class="loading" id="loading-div">
                    <i class="fa fa-spinner fa-pulse fa-3x fa-fw"></i>
                    <span class="sr-only">Loading...</span>
                </div>

                -->

                    <div id="right" class="clearfix">
                        <div class="resultCount" id="resultCount"></div>
                        <hr />
                        <div id="searchResults">
                            <!--
                      
<div id="post">
    <div class="post-header">
    <div id="post-meta" class="row">
        <div class="col-lg-6">5 November 2022</div>
        
    </div>
    <h2>Learn You A Kee-Frame, Part 5</h2>
</div>
<div>
    
    <blockquote><p>It was my pork chop. But that's ok. I ate his dog food.</p><p>-- Bam Bam Bigelow</p></blockquote><p>The program is not finished, but this part is when it becomes useful.
I just used it in a training session for the first time.  Haha!  Hahaha!</p><h2 id="storage">Storage</h2><p>I had a hard time deciding what to use for storage.  I was pretty far
along with a PouchDB version.  I very much want some kind of sync
between my phone and other devices, PouchDB would be one option.
But this program might be useful for non-technical people,
so I want to make it rock solid.  And so far I have not come
up with a convincing strategy for dealing with eventual conflicts.</p><p>But the storage layer is built with an eye to PouchDB.
In particular, we are producing bog standard JSON that
could be used in a JSON aware database.</p><p>On initialization, there is code in place that reads
<code>:current</code>, <code>:exercises</code> and <code>:programs</code> from local storage.
Right now I injecting them as coeffects, this is only
possible with local storage because it is synchronous.
With PouchDB or IndexedDB, we would have to dispatch
additional events, like we do after reading <code>config.json</code>
over http.</p><pre><code class="clojure">(rf/reg-event-fx :config-loaded
                 [(rf/inject-cofx :grmble.lyakf.frontend.storage.local/load 
                   [:current :exercises :programs])]
                 (fn [{:keys [db current exercises programs]} [_ config]]
                   {:db (cond-&gt; (assoc db :config (merge (:config db) config))
                          true      (assoc-in [:transient :initialized?] true)
                          current   (assoc :current (foreign/js-&gt;current current))
                          exercises (assoc :exercises (foreign/js-&gt;exercises exercises))
                          programs  (assoc :programs (foreign/js-&gt;programs programs)))}))
</code></pre><p>This is the event handler for the <code>:complete</code> event that is
dispatched by the program wizard.</p><p>2 new side effects are used: <code>:store</code> writes the <code>:current</code> part
of app db to local storage. <code>:append-history</code> writes history entries.
This will be used later on to produce our fancy charts (with lines
going ever up!!!).</p><p>The current weights for all exercises are now stored under <code>[:current :weights]</code>.
This is for PouchDB: if there is a conflict with writing this, there might
be changes that are hidden to the user, but at least it would be consistent.</p><p>Now <code>:exercises</code> only changes for configuration changes, same thing with
<code>:programs</code>.</p><pre><code class="clojure">(defn complete-handler [{:keys [db current-date]} [_ selector repsets]]
  (let [slug                   (get-in db [:current :slug])
        program                (-&gt; db :programs (get slug))
        xref                   (program/exercise-ref program selector)
        [completed-slugs data] (program/complete-with-slugs repsets program
                                                            (-&gt; db :current :data)
                                                            selector)
        db (-&gt; db
               (update :current
                       #(reduce (incrementer (:exercises db)) % completed-slugs))
               (update :current #(assoc % :data data)))]
    {:db db

     :grmble.lyakf.frontend.storage.local/store
     {:kvs {:current (foreign/current-&gt;js (:current db))}
      :db db}

     :grmble.lyakf.frontend.storage.local/append-history
     {:current-date current-date
      :slug (:slug xref)
      :repsets repsets}}))
</code></pre><p>Note the use of namespaced keywords.  The idea here is that additional
storage backends would provide the same effects and co-effects,
just in different namespaces.  This would allow to switch between
them.  We would have to stop using coeffects for reading though.</p><h2 id="history">History</h2><p>The data tab now shows our history entries.</p><p>Codemirror is very powerful, we could make a
<code>lezer</code> version of our entry parser and we would
have syntax hightlighting.</p><pre><code class="clojure">(defn- codemirror-content [view]
  (some-&gt; view .-state .-doc .-text))

;; the inner / outer pattern comes straigt from the docs
;; https://day8.github.io/re-frame/Using-Stateful-JS-Components/
(defn codemirror-inner []
  (let [view     (atom nil)
        init!    (fn [comp]
                   (let [history     (:history (r/props comp))
                         state       (.-state @view)
                         length      (or (some-&gt; state .-doc .-length)
                                         0)
                         transaction (.update state #js {:changes #js {:from 0
                                                                       :to length
                                                                       :insert history}})]
                     (.dispatch @view transaction)))]

    (r/create-class
     {:reagent-render         (fn []
                                [:&lt;&gt;
                                 [:div#codemirror]
                                 [:div.control
                                  [:button.button.is-primary
                                   {:on-click
                                    #(&gt;evt [:save-history (codemirror-content @view)])}
                                   "Save"]]])

      :component-did-mount    (fn [comp]
                                (let [elem  (js/document.getElementById "codemirror")
                                      cm    (EditorView.
                                             #js {:extensions #js [basicSetup]
                                                  :parent elem})]
                                  (reset! view cm)
                                  (init! comp)))
      :component-did-update    init!
      :display-name            "codemirror-inner"})))


(defn codemirror-outer []
  (let [transient (&lt;sub [:transient])]
    (fn []
      ;; it is a map so it can be accessed as (r/props cmop)
      [codemirror-inner transient])))
</code></pre><p>For now we just detect errors using our insta-parse parser
(see <code>parser/parse-history</code>) and display the affected
line numbers via flash.</p><p>The history is not usually loaded. For charting, we will only
use a limited subset of the data, so we do not keep it in memory.
I actually worked for quite a while on this because I forgot
about kee-frame's controllers.  Duh.  This is just what
they are for, and the code is so much nicer than my
pure re-frame attempt using <code>reg-sub-raw</code>:</p><pre><code class="clojure">(k/reg-controller :data
                  {:params (fn [match]
                             (when (= (get-in match [:data :name]) :data)
                               true))
                   :start  [:load-history]
                   :stop   [:dispose-history]})
</code></pre><h2 id="resetting-exercises-and-snapshots">Resetting Exercises and Snapshots</h2><p>In the wizard, there is now a reset button next to each exercise.
This toggles a modal form for changing the exercise's current weight:</p><pre><code class="clojure">(defn reset-exercise [exercise show? toggle]
  (r/with-let [value (r/atom (:weight exercise))]
    (let [reset-exercise! (fn [evt]
                            (&gt;evt [:reset-exercise (:slug exercise) @value])
                            (toggle evt))]
      [:form.modal {:class (when @show? :is-active)
                    :on-submit reset-exercise!}
       [:div.modal-background]
       [:div.modal-card
        [:header.modal-card-head
         [:p.modal-card-title (str "Reset " (:name exercise))] ; without the str a very strange error ...
         [:button.delete {:aria-label "close" :type "button" :on-click toggle}]]
        [:section.modal-card-body
         [:input.input {:on-change #(reset! value (-&gt; % .-target .-value))
                        :value @value}]]
        [:footer.modal-card-foot
         [:button.button.is-success
          {:type "submit"
           :on-click reset-exercise!}
          "Save"]
         [:button.button {:on-click toggle} "Cancel"]]]])))
</code></pre><p>There is also a snapshotting feature:  since I am already using the program,
trying things out on my phone now messes up my data.  The history
is easily cleaned up on the data tab, but the current wizard state
is complicated.  So on the dev tab, there are 2 new buttons:
"Snapshot" and "Restore".  I make a snapshot before loading a new build.
This stores the entire <code>:current</code> part of the model into local storage
under a different name.  When I am done playing around I press <code>:restore</code>,
this replaces regular <code>:current</code> storage with the snapshot and also
loads it back in.</p><pre><code class="clojure">(rf/reg-event-fx :snapshot-current
                 (fn [{:keys [db]} [_]]
                   {:db db

                    :grmble.lyakf.frontend.storage.local/store
                    {:kvs {:snapshot (foreign/current-&gt;js (:current db))}
                     :db db}}))

(rf/reg-event-fx :restore-snapshot
                 [(rf/inject-cofx :grmble.lyakf.frontend.storage.local/load [:snapshot])]
                 (fn [{:keys [db snapshot]} [_]]
                   {:db (cond-&gt; db
                          snapshot  (assoc :current (foreign/js-&gt;current snapshot)))

                    :grmble.lyakf.frontend.storage.local/store
                    {:kvs {:current snapshot}
                     :db db}}))
</code></pre><h2 id="release-build-on-gh-pages">Release Build on GH Pages</h2><ul><li><a href="https://grmble.github.io/learn-you-a-keeframe/part5/">Demo: Learn you a Kee-Frame, Part 5</a></li><li><a href="https://github.com/grmble/learn-you-a-keeframe/tree/part5">Source code</a></li></ul><p>340 KB compressed.  Codemirror is a big dependency, but so far I am happy
with the load times.  My phone is a couple of years old now and it runs
like a charm.</p>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags-output/lyakf/">lyakf</a>
    
    <a href="/tags-output/clojure/">clojure</a>
    
</div>


    <div id="prev-next">
        
        
        <a class="right" href="/posts-output/2022-10-31-learn-you-a-keeframe-part-4/">Learn You A Kee-Frame, Part 4 &raquo;</a>
        
    </div>

    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = "https://grmble.github.io/posts-output/2022-11-05-learn-you-a-keeframe-part-5/";
            this.page.identifier = "Learn You A Kee-Frame, Part 5";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//grmble-github-io.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    


</div>

                        -->
                        </div>

                        <h3>Links</h3>
                        <ul id="links">
                            <li><a href="http://cryogenweb.org/docs/home.html">Cryogen Docs</a></li>
                            
                        </ul>
                        
                        <div id="recent">
                            <h3>Recent Posts</h3>
                            <ul>
                                
                                <li><a href="/posts-output/2022-11-05-learn-you-a-keeframe-part-5/">Learn You A Kee-Frame, Part 5</a></li>
                                
                                <li><a href="/posts-output/2022-10-31-learn-you-a-keeframe-part-4/">Learn You A Kee-Frame, Part 4</a></li>
                                
                                <li><a href="/posts-output/2022-10-28-learn-you-a-keeframe-part-3/">Learn You A Kee-Frame, Part 3</a></li>
                                
                            </ul>
                        </div>
                        
                        
                        <div id="tags">
                            <h3>Tags</h3>
                            <ul>
                                
                                <li><a href="/tags-output/lyakf/">lyakf</a></li>
                                
                                <li><a href="/tags-output/clojure/">clojure</a></li>
                                
                            </ul>
                        </div>
                        
                    </div>
                </div>
            </div>
            <footer>Copyright &copy; 2022 Juergen Gmeiner
                <p style="text-align: center;">Powered by <a href="http://cryogenweb.org">Cryogen</a></p>
            </footer>
        </div>
        <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
        <script src="/js/highlight.pack.js" type="application/javascript"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        
        
</body>
<script>window.onload = startlunr();</script>

</html>
